<?xml version="1.0"?>
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
         xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <modelVersion>4.0.0</modelVersion>
    <groupId>cn.kanyun</groupId>
    <artifactId>cpa</artifactId>
    <packaging>pom</packaging>
    <name>cpa</name>
    <version>0.0.1-SNAPSHOT</version>
    <url>http://maven.apache.org</url>


    <modules>
        <module>cpa-dao</module>
        <module>cpa-service</module>
        <module>cpa-model</module>
        <module>cpa-web</module>
        <module>cpa-util</module>
        <module>cpa-lucene</module>
        <module>cpa-provide</module>
        <module>cpa-chat</module>
    </modules>
    <!--上传私服 pom.xml 配置,发布自己的jar包,本文件仅为pom文件故不参与部署-->
    <!--自动发布构件到远程仓库，在本地工程目录下执行：mvn deploy 所部署的包就自动上传到了nexus安装目录下-->
    <!--<distributionManagement>-->
    <!--<repository>-->
    <!--&lt;!&ndash;这个ID需要与你的release仓库的Repository ID一致&ndash;&gt;-->
    <!--<id>releases</id>-->
    <!--<url>http://192.168.1.11:8081/nexus/content/repositories/releases</url>-->
    <!--</repository>-->
    <!--<snapshotRepository>-->
    <!--&lt;!&ndash;这个ID需要与你的snapshots仓库的Repository ID一致&ndash;&gt;-->
    <!--<id>snapshots</id>-->
    <!--<url>http://192.168.1.11:8081/nexus/content/repositories/snapshots</url>-->
    <!--</snapshotRepository>-->
    <!--</distributionManagement>-->
    <!--增加仓库配置,不然可能插件找不到,导致报错-->
    <repositories>
        <!--如有Nexus私服, 取消注释并指向正确的服务器地址,需要注意的是配置私服后,所有的jar包将在从私服中下载,如果私服中没有,则私服从其他仓库下载到私服内,再下载到本地的开发环境,所以如果私服从其他仓库下载的jar包不完整,那么本地的jar包也是不完整的,这个时候需要注释掉私服的配置,使开发环境从其他仓库下载,或者操作私服重新下载jar包-->
        <!--https://blog.csdn.net/kimylrong/article/details/23280155-->
        <!--其主要下载的还是我们自己打的项目中需要依赖的jar包-->
        <!--<repository>-->
        <!--<id>nexus-repos</id>-->
        <!--<name>Team Nexus Repository</name>-->
        <!--<url>http://115.47.155.3:8086/nexus/content/groups/public</url>-->
        <!--<releases>-->
        <!--<enabled>true</enabled>-->
        <!--</releases>-->
        <!--<snapshots>-->
        <!--<enabled>true</enabled>-->
        <!--</snapshots>-->
        <!--</repository>-->
        <!--一些公共meven库-->
        <repository>
            <id>spring-snapshots</id>
            <name>Spring Snapshots</name>
            <url>https://repo.spring.io/libs-snapshot</url>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
        </repository>
        <repository>
            <id>central</id>
            <name>Central Repository</name>
            <url>http://maven.aliyun.com/nexus/content/repositories/central</url>
            <layout>default</layout>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>
        <repository>
            <id>mvn-repository</id>
            <name>Mvn Repository</name>
            <url>http://mvnrepository.com/repos</url>
            <layout>default</layout>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>

    </repositories>

    <!--构建该项目或使用该插件所需要的Maven的最低版本-->
    <prerequisites>
        <maven>3.5.2</maven>
    </prerequisites>

    <properties>
        <!-- 指明编译源代码时使用的字符编码，maven编译的时候默认使用的GBK编码， 通过project.build.sourceEncoding属性设置字符编码，告诉maven这个项目使用UTF-8来编译 -->
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <spring-framework-version>5.0.2.RELEASE</spring-framework-version>
        <hibernate-framework-version>5.1.2.Final</hibernate-framework-version>
    </properties>

    <build>
        <!--定制打包后的包名,默认打包后包名为 ${project.artifactId}-${project.version} -->
        <finalName>cpaweb</finalName>
        <resources>
            <resource>
                <directory>${project.basedir}/src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
                <!--是否替换资源中的属性,与maven-profile相关,建议配置在各个子模块的pom.xml文件中-->
                <filtering>true</filtering>
            </resource>
        </resources>
        <!--pluginManagement是表示插件声明，即你在项目中的pluginManagement下声明了插件，Maven不会加载该插件,pluginManagement声明可以被继承-->
        <!--pluginManagement一般是用来在父POM中定义，提供给子POM使用，子POM也可以覆盖这个定义，而且你在父POM中定义了版本之后，子模块中直接应用groupId和artifactId，而不用指定版本，同时也方便统一管理；而在父POM中的pluginManagement并不会介入到Maven的生命周期。-->
        <!--plugins就是直接引入一个plugin，而且可以绑定到Maven相关的生命周期上,pluginManagement主要是为了统一管理插件，确保所有子POM使用的插件版本保持一致，类似dependencies和dependencyManagement。-->
        <pluginManagement>
            <plugins>
                <!--设置maven编译的JDK版本-->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.6.0</version>
                    <configuration>
                        <source>1.8</source>
                        <target>1.8</target>
                        <!--未指明编译源代码时使用的字符编码， maven编译的时候默认使用的GBK编码， 通过encoding属性设置字符编码， 告诉maven这个项目使用UTF-8来编译 -->
                        <encoding>utf8</encoding>
                    </configuration>
                </plugin>
                <!--设置maven-tomcat7热部署,需设置权限-->
                <plugin>
                    <groupId>org.apache.tomcat.maven</groupId>
                    <artifactId>tomcat7-maven-plugin</artifactId>
                    <version>2.2</version>
                    <configuration>
                        <!--配置该url貌似没有用,所以配置port 与path即可-->
                        <!--<url>http://localhost:8080/cpa</url>-->
                        <port>8899</port>
                        <!--path就是地址的配置，默认值是/${project.artifactId}-->
                        <path>/</path>
                        <!-- 与settings.xml文件中Server的id相同 -->
                        <server>tomcat8</server>
                        <username>tomcat</username>
                        <password>tomcat</password>
                        <uriEncoding>UTF-8</uriEncoding>
                        <update>true</update>
                        <!--配置打包名和打包路径，测试不必要，打包后的名称为build标签下的finalName标签的值-->
                        <!--<warFile>${basedir}/target/${project.build.finalName}.war</warFile>-->
                    </configuration>
                </plugin>

                <!--在Maven进行test、package、install等命令时，会默认使用 maven-surefire-plugin 插件来生成测试报告，此种方式生成的为XML文件和TXT类型文件。并存放在其自动生成的目录surefire-reports下-->
                <!--引入插件依赖以及运行test命令的编译结果，注意该命令如果不指定测试类的地址，默认会扫描maven目录结构下test目录中类似-->
                <!--1、Test*.java:任何目录下以Test为开始的类-->
                <!--2、*Test.java: 任何目录下以Test为结尾的类-->
                <!--3、*TestCase.java: 任何目录下以TestCase为结尾的类-->
                <!--如果需要生成HTML的测试报告，运行Maven命令 mvn test surefire-report:report  即是：运行mvn test的基础上，根据生成的xml、txt文件，再生成默认格式的report-->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-surefire-plugin</artifactId>
                    <version>2.22.2</version>
                    <configuration>
                        <forkMode>once</forkMode>
                        <argLine>-Dfile.encoding=UTF-8</argLine>
                        <!--等同如下配置：mvn test -Dmaven.test.skip=true-->
                        <!--<skipTests>true</skipTests>-->
                        <!--maven中默认的情况下如果单元测试有错误(这个错误分两种:一是编译不过去的错误,二是单元测试的结果是跟Assert的期望值不一致,对于编译不过去的错误要及早解决),将会停止构建工程，如果想忽略错误而继续构建的话,设置为true,默认为false-->
                        <testFailureIgnore>true</testFailureIgnore>
                        <!--若此目录为空，则会在maven命令test执行结束之后，显示以上结果 ： No tests to run.-->
                        <includes>
                            **/*.java
                        </includes>
                        <excludes>
                            <!-- -->
                        </excludes>

                    </configuration>
                </plugin>


                <!--maven-site-plugin是一个负责为Java项目生成静态HTML网站的插件。这个插件非常的有用，里面可以嵌入各种插件，比如用来对代码检查bug的findbugs,检查代码风格的checkstyle,生成testng测试报告的surefire等-->
                <!--使用方法：mvn site 生成的html文件在 target/site 执行mvn site:deploy部署到Web服务器-->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-site-plugin</artifactId>
                    <version>3.7.1</version>
                    <configuration>
                        <!--站点的生成是基于Velocity模板的，默认使用default-site.vm模板，可以在pom.xml中配置其他模板文件-->
                        <!--<templateFile>${basedir}/maven-site.vm</templateFile>-->
                        <!--源代码中的站点国际化-->
                        <locales>en,zh</locales>
                    </configuration>

                </plugin>


                <!--多模块Maven项目如何使用javadoc插件生成文档-->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-javadoc-plugin</artifactId>
                    <version>2.10.4</version>
                    <configuration>
                        <aggregate>true</aggregate>
                    </configuration>
                </plugin>
                <!--maven-source-plugin插件,主要是生成jar，运行mvn clean package生成jar包，再执行一条命令：mvn deploy就可以发布到你自己的私服上了-->
                <plugin>
                    <artifactId>maven-source-plugin</artifactId>
                    <version>3.0.1</version>
                    <configuration>
                        <attach>true</attach>
                    </configuration>
                    <executions>
                        <execution>
                            <phase>package</phase>
                            <goals>
                                <goal>jar-no-fork</goal>
                            </goals>
                        </execution>
                    </executions>
                </plugin>

                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-clean-plugin</artifactId>
                    <version>2.5</version>
                </plugin>

                <!--maven assembly插件,用来打jar包[其可以实现，自定义打可运行的jar包]-->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-assembly-plugin</artifactId>
                    <version>3.1.1</version>
                </plugin>

                <!--使用docker-maven-plugin 进行完全免 Dockerfile 文件,注意 EXPOSE 在spring boot 中不起作用-->
                <plugin>
                    <groupId>com.spotify</groupId>
                    <artifactId>docker-maven-plugin</artifactId>
                </plugin>

                <!--resource插件的功能就是把项目需要的配置文件拷贝到指定的目当，默认是拷贝src\main\resources目录下的件到classes目录下，当然可以自己来配置源目录和输出目录。resources插件一般不单独执行，complie插件执行时会先调用resources插件-->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-resources-plugin</artifactId>
                    <version>3.1.0</version>
                </plugin>

                <!--mybatis代码生成插件-->
                <plugin>
                    <groupId>org.mybatis.generator</groupId>
                    <artifactId>mybatis-generator-maven-plugin</artifactId>
                    <version>1.3.7</version>
                    <!-- 数据库驱动  -->
                    <dependencies>
                        <dependency>
                            <groupId>mysql</groupId>
                            <artifactId>mysql-connector-java</artifactId>
                            <version>5.1.8</version>
                        </dependency>
                    </dependencies>
                    <!-- 自动生成 -->
                    <executions>
                        <execution>
                            <id>Generate MyBatis Artifacts</id>
                            <goals>
                                <goal>generate</goal>
                            </goals>
                            <configuration>
                                <!-- 指定文件位置好像不起作用，始终默认读取src/main/resources/generatorConfig.xml文件 -->
                                <configurationFile>src/main/resources/generatorConfig.xml</configurationFile>
                                <!--允许移动生成的文件-->
                                <verbose>true</verbose>
                                <!--允许覆盖生成的文件-->
                                <overwrite>true</overwrite>
                            </configuration>
                        </execution>
                    </executions>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>


    <!--dependencyManagement,一般是用来在父POM中定义，提供给子POM使用，子POM也可以覆盖这个定义,而且你在父POM中定义了版本之后，子模块中直接应用groupId和artifactId，而不用指定版本，同时也方便统一管理；而在父POM中的pluginManagement并不会介入到Maven的生命周期-->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>com.ruifight</groupId>
                <artifactId>oa-remote</artifactId>
                <version>1.1.0</version>
            </dependency>
            <!--Junit单元测试-->
            <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>4.12</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-test</artifactId>
                <version>${spring-framework-version}</version>
                <!--把<scope></scope>标签去掉 否则无法使用 @ContextConfiguration-->
                <!--<scope>lombok</scope>-->
            </dependency>
            <!--Spring相关-->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
                <version>${spring-framework-version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-core</artifactId>
                <version>${spring-framework-version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-beans</artifactId>
                <version>${spring-framework-version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-webmvc</artifactId>
                <version>${spring-framework-version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-web</artifactId>
                <version>${spring-framework-version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-orm</artifactId>
                <version>${spring-framework-version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-aop</artifactId>
                <version>${spring-framework-version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-tx</artifactId>
                <version>${spring-framework-version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-websocket</artifactId>
                <version>${spring-framework-version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-messaging</artifactId>
                <version>${spring-framework-version}</version>
            </dependency>
            <!--spring bom 解决spring依赖多版本问题,引入该POM文件后,再引入其他spring的jar包可不标明版本-->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-framework-bom</artifactId>
                <version>4.3.5.RELEASE</version>
                <type>pom</type>
            </dependency>


            <!--shiro权限控制-->
            <dependency>
                <groupId>org.apache.shiro</groupId>
                <artifactId>shiro-all</artifactId>
                <version>1.3.2</version>
            </dependency>

            <!--Hibernate相关-->
            <dependency>
                <groupId>org.hibernate</groupId>
                <artifactId>hibernate-entitymanager</artifactId>
                <version>${hibernate-framework-version}</version>
            </dependency>
            <dependency>
                <groupId>org.hibernate.common</groupId>
                <artifactId>hibernate-commons-annotations</artifactId>
                <version>5.0.1.Final</version>
            </dependency>
            <dependency>
                <groupId>org.hibernate.javax.persistence</groupId>
                <artifactId>hibernate-jpa-2.0-api</artifactId>
                <version>1.0.1.Final</version>
            </dependency>
            <dependency>
                <groupId>org.hibernate</groupId>
                <artifactId>hibernate-core</artifactId>
                <version>${hibernate-framework-version}</version>
                <exclusions>
                    <exclusion>
                        <groupId>org.jboss.logging</groupId>
                        <artifactId>jboss-logging</artifactId>
                    </exclusion>
                </exclusions>
            </dependency>
            <!--需要注意的是，Hibernate Validator 与 Hibernate 没有任何依赖关系，唯一有联系的只是都属于 JBoss 公司的开源项目而已。然后，我们需要在 Spring 配置文件中开启该特性，需添加如下配置：-->
            <!--<bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/>-->
            <!--使用该框架，在javabean上加上@NotEmpty注解，并且在@Controller方法参数中添加@Valid注解实现参数验证,详情百度框架用法-->
            <dependency>
                <groupId>org.hibernate</groupId>
                <artifactId>hibernate-validator</artifactId>
                <version>${hibernate-framework-version}</version>
            </dependency>
            <!--使用Ehcache做Hibernate二级缓存,之前一直想用redis做二级缓存,但是redis还未有实现的案例,
            也有想过使用hibernate memcached来做,但是还需要安装memcached,也是不妥,最有优势的是采用JbossCache做二级缓存,其功能强大,但是又会造成方法冲突
            报错"nested exception is java.lang.NoSuchMethodError: org.jboss.logging.Logger.getMessageLogger(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Object;"
            故作罢,选择最稳妥的Ehcache了-->
            <dependency>
                <groupId>org.hibernate</groupId>
                <artifactId>hibernate-ehcache</artifactId>
                <version>${hibernate-framework-version}</version>
            </dependency>
            <!--Hibernate5之后开始支持JDK,比如Date和Time API,之前使用Hibernate4保存日期字段时使用JDk8 LocalDateTime保存会报错,故ORM换成Hibernate5并加上此依赖-->
            <dependency>
                <groupId>org.hibernate</groupId>
                <artifactId>hibernate-java8</artifactId>
                <version>5.1.0.Final</version>
            </dependency>

            <!--使用javax.persistence注解配置PO对象,如@Entity-->
            <dependency>
                <groupId>javax.persistence</groupId>
                <artifactId>persistence-api</artifactId>
                <version>1.0.2</version>
            </dependency>

            <!--消息队列-->
            <dependency>
                <groupId>com.alibaba.rocketmq</groupId>
                <artifactId>rocketmq-client</artifactId>
                <version>3.2.6</version>
            </dependency>
            <dependency>
                <groupId>com.alibaba.rocketmq</groupId>
                <artifactId>rocketmq-all</artifactId>
                <version>3.2.6</version>
                <type>pom</type>
            </dependency>

            <!--Netty网络通讯-->
            <!--<dependency>-->
            <!--<groupId>io.netty</groupId>-->
            <!--<artifactId>netty-all</artifactId>-->
            <!--<version>5.0.0.Alpha2</version>-->
            <!--</dependency>-->

            <!--JBoss Marshalling 是一个Java对象的序列化API包，修正了JDK自带的序列化包的很多问题，但又保持跟 java.io.Serializable 接口的兼容，通常用于Netty编解码应用-->
            <dependency>
                <groupId>org.jboss.marshalling</groupId>
                <artifactId>jboss-marshalling</artifactId>
                <version>2.0.6.Final</version>
            </dependency>

            <!--使用redis-->
            <dependency>
                <groupId>com.github.debop</groupId>
                <artifactId>hibernate-redis</artifactId>
                <version>2.3.2</version>
            </dependency>
            <dependency>
                <groupId>redis.clients</groupId>
                <artifactId>jedis</artifactId>
                <version>2.9.0</version>
            </dependency>
            <!--Redisson是一个基于java编程框架netty进行扩展了的redis,分开源版本和商业版(Redisson PRO),所以选择的时候请谨慎。（Map）和集（Set）数据分片功能仅限于Redisson PRO版本才有，另外Redis部署工具和集群管理工具功能仅限于Redisson PRO版本才有-->
            <dependency>
                <groupId>org.redisson</groupId>
                <artifactId>redisson</artifactId>
                <version>3.10.7</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.data</groupId>
                <artifactId>spring-data-redis</artifactId>
                <version>2.1.3.RELEASE</version>
            </dependency>


            <!--数据连接相关-->
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>5.1.8</version>
            </dependency>
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>druid</artifactId>
                <version>1.1.6</version>
            </dependency>

            <!--Quartz定时任务-->
            <dependency>
                <groupId>org.quartz-scheduler</groupId>
                <artifactId>quartz</artifactId>
                <version>2.3.0</version>
            </dependency>

            <!--日志记录-->
            <!--slf4j的核心包,只有日志的接口，并没有实现-->
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-api</artifactId>
                <version>1.7.9</version>
            </dependency>
            <!--slf4j转换各日志实现包-->
            <!--<dependency>-->
            <!--<groupId>org.slf4j</groupId>-->
            <!--<artifactId>slf4j-log4j12</artifactId>-->
            <!--<version>1.7.9</version>-->
            <!--</dependency>-->
            <!--日志实现包-->
            <!--<dependency>-->
            <!--<groupId>log4j</groupId>-->
            <!--<artifactId>log4j</artifactId>-->
            <!--<version>1.2.17</version>-->
            <!--</dependency>-->
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-classic</artifactId>
                <version>1.2.3</version>
            </dependency>
            <dependency>
                <groupId>org.logback-extensions</groupId>
                <artifactId>logback-ext-spring</artifactId>
                <version>0.1.4</version>
            </dependency>
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-core</artifactId>
                <version>1.2.3</version>
            </dependency>
            <!--logback 配置ELK依赖-->
            <dependency>
                <groupId>net.logstash.logback</groupId>
                <artifactId>logstash-logback-encoder</artifactId>
                <version>5.3</version>
            </dependency>
            <!--logback-access.jar包是通过互联网访问日志时需要的JAR包-->
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-access</artifactId>
                <version>1.2.3</version>
            </dependency>
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>jcl-over-slf4j</artifactId>
                <version>1.7.9</version>
            </dependency>

            <!--Excel导入导出-->
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi-ooxml</artifactId>
                <version>3.9</version>
            </dependency>
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi</artifactId>
                <version>3.9</version>
            </dependency>
            <!--上面的包是精简包，为了节省空间，里面放的只有一些常用的模块，所以要引用另外一些功能的话就需要引用完全版的ooxml-schemas.jar包-->
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi-ooxml-schemas</artifactId>
                <version>3.9</version>
            </dependency>
            <!--word模板渲染组件-->
            <dependency>
                <groupId>com.deepoove</groupId>
                <artifactId>poi-tl</artifactId>
                <version>1.2.0</version>
            </dependency>

            <dependency>
                <groupId>org.freemarker</groupId>
                <artifactId>freemarker</artifactId>
                <version>2.3.9</version>
            </dependency>

            <!--JSON解析和序列化-->
            <dependency>
                <groupId>net.sf.json-lib</groupId>
                <artifactId>json-lib</artifactId>
                <version>2.4</version>
                <classifier>jdk15</classifier>
            </dependency>
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-core</artifactId>
                <version>2.9.2</version>
            </dependency>
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-annotations</artifactId>
                <version>2.9.2</version>
            </dependency>
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>2.9.2</version>
            </dependency>
            <!--该依赖为谷歌Gson包，使用最多的是Gson类的toJson()和fromJson()方法-->
            <dependency>
                <groupId>com.google.code.gson</groupId>
                <artifactId>gson</artifactId>
                <version>2.8.0</version>
            </dependency>
            <!-- fastJson json数组有关的 -->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>1.2.57</version>
            </dependency>
            <!-- 支持java8 localDate等新时间类型的序列化 -->
            <dependency>
                <groupId>com.fasterxml.jackson.datatype</groupId>
                <artifactId>jackson-datatype-jsr310</artifactId>
                <version>2.9.2</version>
            </dependency>

            <!--Guava是谷歌开源的java库.这个库提供用于集合，缓存，支持原语，并发性，常见注解，字符串处理，I/O和验证的实用方法-->
            <dependency>
                <groupId>com.google.guava</groupId>
                <artifactId>guava</artifactId>
                <version>27.1-jre</version>
            </dependency>

            <!--Java系统监控(淘汰sigar)-->
            <dependency>
                <groupId>com.github.oshi</groupId>
                <artifactId>oshi-core</artifactId>
                <version>3.13.0</version>
            </dependency>

            <!--swagger2 引用生成 RestAPI文档-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>2.9.2</version>
            </dependency>
            <!--版本查找https://search.maven.org/search?q=g:com.github.caspar-chen%20AND%20a:swagger-ui-layer-->
            <dependency>
                <groupId>com.github.caspar-chen</groupId>
                <artifactId>swagger-ui-layer</artifactId>
                <version>1.1.3</version>
            </dependency>
            <!--swagger2 可能需要的额外JAR包-->
            <dependency>
                <groupId>com.fasterxml</groupId>
                <artifactId>classmate</artifactId>
                <version>1.4.0</version>
            </dependency>

            <!--XML解析-->
            <dependency>
                <groupId>dom4j</groupId>
                <artifactId>dom4j</artifactId>
                <version>1.6.1</version>
            </dependency>

            <!--dubbo远程过程调用(RPC)所需依赖-->
            <!--在做dubbo的时候出现java.lang.NoSuchMethodError: org.springframework.beans.MutablePropertyValues.add是因为用maven的时候其他包被引入进来了;把一些重复的包exclusion就可以了！-->
            <!--在做dubbo的时候出现dubbo nested exception is java.lang.ExceptionInInitializerError异常，解决方法换个javassist包,如3.18.2-GA版本-->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>dubbo</artifactId>
                <version>2.5.8</version>
                <exclusions>
                    <exclusion>
                        <artifactId>spring</artifactId>
                        <groupId>org.springframework</groupId>
                    </exclusion>
                    <exclusion>
                        <artifactId>javassist</artifactId>
                        <groupId>org.javassist</groupId>
                    </exclusion>
                    <exclusion>
                        <artifactId>netty</artifactId>
                        <groupId>io.netty</groupId>
                    </exclusion>
                </exclusions>
            </dependency>
            <dependency>
                <groupId>org.apache.zookeeper</groupId>
                <artifactId>zookeeper</artifactId>
                <version>3.4.11</version>
                <exclusions>
                    <exclusion>
                        <artifactId>netty</artifactId>
                        <groupId>io.netty</groupId>
                    </exclusion>
                </exclusions>
            </dependency>
            <dependency>
                <groupId>com.github.sgroschupf</groupId>
                <artifactId>zkclient</artifactId>
                <version>0.1</version>
                <exclusions>
                    <exclusion>
                        <artifactId>netty</artifactId>
                        <groupId>io.netty</groupId>
                    </exclusion>
                </exclusions>
            </dependency>
            <!--Curator解决了很多ZooKeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等,除了封装一些开发人员不需要特别关注的底层细节之外，Curator还在ZooKeeper原生API的基础上进行了包装，提供了一套易用性和可读性更强的Fluent风格的客户端API框架-->
            <!--对zookeeper的底层api的一些封装-->
            <dependency>
                <groupId>org.apache.curator</groupId>
                <artifactId>curator-framework</artifactId>
                <version>4.0.0</version>
            </dependency>
            <!--提供一些客户端的操作，例如重试策略等-->
            <dependency>
                <groupId>org.apache.curator</groupId>
                <artifactId>curator-client</artifactId>
                <version>4.0.0</version>
            </dependency>
            <!--封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等-->
            <dependency>
                <groupId>org.apache.curator</groupId>
                <artifactId>curator-recipes</artifactId>
                <version>4.0.0</version>
            </dependency>

            <!--为防止与tomcat中的servlet发生冲突,导致服务无法启动,所以加上scope定义该jar包的使用范围-->
            <dependency>
                <groupId>javax.servlet.jsp</groupId>
                <artifactId>jsp-api</artifactId>
                <scope>provided</scope>
                <version>2.2</version>
            </dependency>
            <dependency>
                <groupId>javax.servlet</groupId>
                <artifactId>javax.servlet-api</artifactId>
                <scope>provided</scope>
                <version>4.0.0</version>
            </dependency>
            <dependency>
                <groupId>javax.websocket</groupId>
                <artifactId>javax.websocket-api</artifactId>
                <scope>provided</scope>
                <version>1.1</version>
            </dependency>


            <!--文件上传-->
            <dependency>
                <groupId>commons-fileupload</groupId>
                <artifactId>commons-fileupload</artifactId>
                <version>1.2.1</version>
            </dependency>

            <!--FTP-->
            <dependency>
                <groupId>commons-net</groupId>
                <artifactId>commons-net</artifactId>
                <version>3.5</version>
                <classifier>ftp</classifier>
            </dependency>

            <!-- aspectjweaver.jar这是Spring AOP所要用到的包 -->
            <dependency>
                <groupId>org.aspectj</groupId>
                <artifactId>aspectjweaver</artifactId>
                <version>1.8.10</version>
            </dependency>


            <!--图片处理,但需要操作系统安装ImageMagick或者GraphicsMagick再配好环境变量。-->
            <dependency>
                <groupId>org.im4java</groupId>
                <artifactId>im4java</artifactId>
                <version>1.4.0</version>
            </dependency>
            <!--Thumbnailator 是一个优秀的图片处理的Google开源Java类库-->
            <dependency>
                <groupId>net.coobird</groupId>
                <artifactId>thumbnailator</artifactId>
                <version>0.4.8</version>
            </dependency>
            <!--Json Web Token验证，主要用于生成Token-->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>0.9.0</version>
            </dependency>
            <!--邮件处理-->
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-email</artifactId>
                <version>1.5</version>
            </dependency>
            <!-- project lombok 项目中使用Lombok可以减少很多重复代码的书写。比如说getter/setter/toString等方法的编写-->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>1.18.2</version>
                <scope>provided</scope>
            </dependency>
            <dependency>
                <groupId>io.github.jupf.staticlog</groupId>
                <artifactId>staticlog</artifactId>
                <version>2.1.9</version>
            </dependency>

            <!--httpclient-->
            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
                <version>4.5</version>
            </dependency>
            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpcore</artifactId>
                <version>4.4.5</version>
            </dependency>
            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpmime</artifactId>
                <version>4.5</version>
            </dependency>

            <!--HSQLDB是一个轻量级的纯Java开发的开放源代码的关系数据库系统，其体积小，占用空间小，使用简单，支持内存运行方式等特点,同类型比较有名的数据库有H2数据库-->
            <!--Hsqldb有四种运行模式：-->
            <!--一、内存（Memory-Only）模式：所有的数据都将在内存中完成，如果程序退出，则相应的数据也将同时被销毁-->
            <!--二、进行（In-Process）模式：此模式从应用程序启动数据库，由于所有的数据都将写到文件中，所以，即使程序退出，数据也不会被销毁-->
            <!--三、服务器模式：此模式下 HSQLDB 跟其它数据库服务器一样，需要通过服务器的形式来进行启动-->
            <!--四、Web服务器模式：此模式以WEB服务器的形式启动，并通过HTTP协议接受客户端命令。从1.7.2版本开始，Web服务器模式的 HSQLDB 开始支持事务处理。-->
            <!--可作为测试使用-->
            <dependency>
                <groupId>org.hsqldb</groupId>
                <artifactId>hsqldb</artifactId>
                <version>2.3.5</version>
            </dependency>

            <!--solr搜索引擎-->
            <!--solr客户端solrj的依赖 -->
            <dependency>
                <groupId>org.apache.solr</groupId>
                <artifactId>solr-solrj</artifactId>
                <version>4.10.1</version>
            </dependency>
            <!--lucene支持-->
            <dependency>
                <groupId>org.apache.lucene</groupId>
                <artifactId>lucene-core</artifactId>
                <version>6.6.0</version>
            </dependency>
            <!--一般分词器，适用于英文分词-->
            <dependency>
                <groupId>org.apache.lucene</groupId>
                <artifactId>lucene-analyzers-common</artifactId>
                <version>6.6.0</version>
            </dependency>
            <!--中文分词器-->
            <dependency>
                <groupId>org.apache.lucene</groupId>
                <artifactId>lucene-analyzers-smartcn</artifactId>
                <version>6.6.0</version>
            </dependency>
            <!--对分词索引查询解析-->
            <dependency>
                <groupId>org.apache.lucene</groupId>
                <artifactId>lucene-queryparser</artifactId>
                <version>6.6.0</version>
            </dependency>
            <!--检索关键字高亮显示-->
            <dependency>
                <groupId>org.apache.lucene</groupId>
                <artifactId>lucene-highlighter</artifactId>
                <version>6.6.0</version>
            </dependency>
            <!--搜索结果分组,类似搜索框,输入一段文件后，出现一下预想值-->
            <!--<dependency>-->
            <!--<groupId>org.apache.lucene</groupId>-->
            <!--<artifactId>lucene-facet</artifactId>-->
            <!--<version>5.2.0-SNAPSHOT</version>-->
            <!--</dependency>-->

            <!--HTML解析-->
            <dependency>
                <groupId>org.jsoup</groupId>
                <artifactId>jsoup</artifactId>
                <version>1.11.3</version>
            </dependency>

            <!--java使用ssh连接Linux并执行命令,需依赖jcraft的jar包-->
            <dependency>
                <groupId>com.jcraft</groupId>
                <artifactId>jsch</artifactId>
                <version>0.1.55</version>
            </dependency>

            <!--其他-->
            <dependency>
                <groupId>commons-io</groupId>
                <artifactId>commons-io</artifactId>
                <version>1.4</version>
            </dependency>
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>3.7</version>
            </dependency>
            <dependency>
                <groupId>commons-collections</groupId>
                <artifactId>commons-collections</artifactId>
                <version>3.2.2</version>
            </dependency>
            <dependency>
                <groupId>org.bitbucket.cowwoc</groupId>
                <artifactId>preconditions</artifactId>
                <version>1.6</version>
            </dependency>

            <dependency>
                <groupId>javax.validation</groupId>
                <artifactId>validation-api</artifactId>
                <version>1.1.0.Final</version>
            </dependency>


            <!--Javassist是一个开源的分析、编辑和创建Java字节码的类库,关于java字节码的处理，目前有很多工具，如bcel，asm。不过这些都需要直接跟虚拟机指令打交道。如果你不想了解虚拟机指令，可以采用javassistjavassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类-->
            <dependency>
                <groupId>org.javassist</groupId>
                <artifactId>javassist</artifactId>
                <version>3.25.0-GA</version>
            </dependency>
            <dependency>
                <groupId>proxool</groupId>
                <artifactId>proxool</artifactId>
                <version>0.8.3</version>
            </dependency>
            <dependency>
                <groupId>org.jgroups</groupId>
                <artifactId>jgroups</artifactId>
                <version>3.0.9.Final</version>
            </dependency>
            <dependency>
                <groupId>org.rhq.helpers</groupId>
                <artifactId>rhq-pluginAnnotations</artifactId>
                <version>3.0.4</version>
            </dependency>
            <dependency>
                <groupId>org.codehaus.woodstox</groupId>
                <artifactId>stax2-api</artifactId>
                <version>3.1.1</version>
            </dependency>
            <dependency>
                <groupId>org.codehaus.woodstox</groupId>
                <artifactId>woodstox-core-asl</artifactId>
                <version>4.1.1</version>
            </dependency>
            <dependency>
                <groupId>org.infinispan</groupId>
                <artifactId>infinispan-core</artifactId>
                <version>5.1.4.FINAL</version>
            </dependency>

            <dependency>
                <groupId>commons-codec</groupId>
                <artifactId>commons-codec</artifactId>
                <version>1.9</version>
            </dependency>
            <dependency>
                <groupId>org.jboss.logging</groupId>
                <artifactId>jboss-logging</artifactId>
                <version>3.3.1.Final</version>
            </dependency>
            <dependency>
                <groupId>org.jboss.spec.javax.transaction</groupId>
                <artifactId>jboss-transaction-api_1.1_spec</artifactId>
                <version>1.0.0.Final</version>
            </dependency>
            <dependency>
                <groupId>commons-pool</groupId>
                <artifactId>commons-pool</artifactId>
                <version>1.6</version>
            </dependency>
            <!--二维码?-->
            <dependency>
                <groupId>com.google.zxing</groupId>
                <artifactId>javase</artifactId>
                <version>3.3.0</version>
            </dependency>

        </dependencies>
    </dependencyManagement>

    <!--实际项目开发时有多套环境,所以我们也就有多套的配置文件,maven提供了在打包时添加额外命令,来打包不同的配置文件,以避免每次修改项目配置,这就是maven-profile-->
    <!--命令用法 mvn clean package -P <环境ID> -->
    <profiles>
        <profile>
            <id>dev</id>
            <properties>
                <!--resources文件夹下的文件夹名称-->
                <profiles.active>dev</profiles.active>
            </properties>
            <activation>
                <!--activeByDefault标签的值为true的话表示为默认的profile，使用mvn install命令起作用的就是默认的-->
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
    </profiles>

</project>
