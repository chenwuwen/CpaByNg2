<?xml version="1.0" encoding="UTF-8"?>

<!--logback配置文件-->
<!--logback在性能上要明显优于log4j，尤其是在大量并发的环境下，并且新增了一些log4j所没有的功能（如将日志文件压缩成zip包等）-->
<!--  logback与log4j一样，也需要在classpath中编写配置文件。但logback配置文件似乎比log4j复杂一些：log4j不仅支持xml格式的配置文件，
  还支持properties格式的，而logback只支持xml格式的。好在官方提供了一个在线工具，可以将log4j的properties文件直接转换成logback的xml文件，
  地址如下：http://logback.qos.ch/translator/ -->

<!-- 这个是根配置文件，一定要有的
     scan：
         是当配置文件被修改后会被重新加载
     scanPeriod:
         设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，
         默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。
      debug：
         当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。
         默认值为false。
                  -->
<configuration scan="true">
    <!-- 日志存放路径 勿在 LogBack 的配置中使用相对路径
        下面的标签可以自己定义
        name：相当于Map的key
        value：就是map的value
        ${catalina.base}是tomcat的当前路径
        /logs：就是tomcat下的日志路径，
        /ehrlog：如果没有目录会默认创建
    -->
    <substitutionProperty name="logbase" value="${catalina.base}/logs/ehrLog/"/>
    <!-- 时间戳：这个时间戳可以作为每日日志的名称 -->
    <timestamp key="bySecond" datePattern="yyyy-MM-dd"/>
    <!-- 日志级别 -->
    <property name="log.root.level" value="DEBUG"/>
    <!-- 其他日志级别 -->
    <property name="log.other.level" value="INFO"/>
    <!-- 日志路径 -->
    <property name="log.base" value="logs"/>
    <!-- 模块名称， 影响日志配置名，日志文件名 -->
    <property name="log.moduleName" value="ntytest"/>
    <!-- 日志文件大小 -->
    <property name="log.max.size" value="100MB"/>

    <!-- appender：
        name相当于一个名称
        class：确定要加载哪个类
        encoder：一定要加 encoder ，
        默认配置为PatternLayoutEncoder
        patter：必填
        ConsoleAppender：也明白是什么意思，就是输出在控制台上-->
    <!-- 配置控制台输出 -->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss} [%thread] [%level] - %m%n
            </pattern>
        </encoder>
    </appender>
    <!-- 把日志存储
        encoding：日志的编码
        file：指定当前生成的日志文件名称
        rollingPolicy：滚动策略
        FileNamePattern：移动文件最后的名称，跟file标签结合使用，
        比如file里面的内容是  1.txt
        那么，FileNamePattern里面写的是2.txt，那么最后文件名就为2.txt
        如果最后结尾是gz或者zip，那么，就会自动打成压缩包
        -->
    <appender name="logFile" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 编码 -->
        <Encoding>UTF-8</Encoding>
        <!-- 按照时间来 -->
        <file>${logbase}ehr.${bySecond}.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志文件输出的文件名 -->
            <!-- 按“天”生成日志文件，"%i"代表第几个文件（从0自增），并压缩成.zip包 -->
            <FileNamePattern>${logbase}ehr.${label}.%d{yyyy-MM-dd}.%i.log.zip</FileNamePattern>
            <!--日志文件保留天数 -->
            <MaxHistory>30</MaxHistory>
            <!-- 在基于时间的基础上，基于文件大小生成日志文件策略 -->
            <TimeBasedFileNamingAndTriggeringPolicy
                    class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <!-- 单个文件不能大于1024MB -->
                <MaxFileSize>1024MB</MaxFileSize>
            </TimeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <!-- 布局 -->
        <encoder>
            <!-- 格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 -->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
        </encoder>
        <append>false</append>

    </appender>

    <!-- 配置错误日志，filter设置日志级别为ERROR -->
    <appender name="ERROR-FILE"
              class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoding>UTF-8</encoding>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志文件输出的文件名 -->
            <FileNamePattern>${LOG_HOME}/NTY-CORE-ERROR-%d{yyyy-MM-dd}-%i.log
            </FileNamePattern>
            <!--日志文件保留天数 -->
            <MaxHistory>30</MaxHistory>
            <TimeBasedFileNamingAndTriggeringPolicy
                    class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <MaxFileSize>1024MB</MaxFileSize>
            </TimeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 -->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} |%-5level |NTY|NA|%thread|
                %logger{50} -
                %msg%n
            </pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- 配置monitor日志，主要用于公司发送告警邮件，设置logger即可，
    调用：Logger logger = LoggerFactory.getLogger("MONITOR");
        就能把日志打印到monitor文件中。
     -->
    <appender name="MONITOR-FILE"
              class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoding>UTF-8</encoding>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志文件输出的文件名 -->
            <FileNamePattern>${LOG_HOME}/NTY-CORE-MONITOR-%d{yyyy-MM-dd}-%i.log
            </FileNamePattern>
            <!--日志文件保留天数 -->
            <MaxHistory>30</MaxHistory>
            <TimeBasedFileNamingAndTriggeringPolicy
                    class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <MaxFileSize>1024MB</MaxFileSize>
            </TimeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 -->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} |%-5level |NTY|NA|%thread|
                %logger{50}|NA|
                %msg%n
            </pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- 配置monitor日志输出 -->
    <logger name="MONITOR">
        <appender-ref ref="MONITOR-FILE"/>
    </logger>


    <!-- 常用loger配置 -->
    <!-- show parameters for hibernate sql 专为 Hibernate 定制 -->
    <logger name="org.hibernate.type.descriptor.sql.BasicBinder" level="TRACE"/>
    <logger name="org.hibernate.type.descriptor.sql.BasicExtractor" level="DEBUG"/>
    <logger name="org.hibernate.SQL" level="DEBUG"/>
    <logger name="org.hibernate.engine.QueryParameters" level="DEBUG"/>
    <logger name="org.hibernate.engine.query.HQLQueryPlan" level="DEBUG"/>

    <!--myibatis log configure-->
    <!-- <logger name="com.apache.ibatis" level="TRACE"/>
    <logger name="java.sql.Connection" level="DEBUG"/>
    <logger name="java.sql.Statement" level="DEBUG"/>
    <logger name="java.sql.PreparedStatement" level="DEBUG"/> -->

    <!-- logger：日志单位
            name：是你当前扫描的哪个包
            level：日志的级别
            additivity：是否要把当前的日志级别，给root根logger
            appender-ref：appender的引用
         -->
    <logger name="cn.kanyun.cpa" level="trace" additivity="true">
        <appender-ref ref="STDOUT"/>
        <appender-ref ref="logFile"/>
    </logger>
    <!-- 默认根节点是INFO级别的日志 -->
    <!-- root：logger的根节点，就这一个，默认名称就是root
        level：日志级别
        appender-ref：确定使用哪个appender
         -->
    <root level="info">
        <!-- 启用文件记录日志 -->
        <appender-ref ref="logFile"/>
        <!-- 启用控制台输出日志 -->
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>